This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-29T21:10:40.328Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.env.template
.gitignore
LICENSE
README.md
render.yaml
requirements.txt
src/app.py
src/config.py
src/services/api_service.py
src/services/display.py
src/utils/__init__.py
src/utils/formatters.py
src/utils/validators.py
tests/test_display.py

================================================================
Repository Files
================================================================

================
File: .env.template
================
# Server Configuration
PORT=8080
HOST=0.0.0.0
DEBUG=False

# Plugin Configuration
REFRESH_INTERVAL=900  # 15 minutes in seconds

# TRMNL Configuration
TRMNL_API_KEY=your_trmnl_api_key_here
TRMNL_PLUGIN_UUID=your_plugin_uuid_here

# Display Configuration
DISPLAY_WIDTH=800
DISPLAY_HEIGHT=480

# Cache Configuration
CACHE_TIMEOUT=600  # 10 minutes in seconds

================
File: .gitignore
================
# Project-specific files
.env
api_test.py

# Python
__pycache__/
*.py[cod]
*.class
.Python
env/
venv/
build/
dist/
*.egg-info/

# IDE
.idea/
.vscode/
*.swp

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Testing
.coverage
htmlcov/
.pytest_cache/

================
File: LICENSE
================
MIT License

Copyright (c) 2024 OptimumMeans

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# TRMNL Plugin Boilerplate

A boilerplate template for creating TRMNL e-ink display plugins.

## Features

- Flask-based webhook endpoint with CORS support
- E-ink display optimization
- Built-in caching system
- Comprehensive error handling
- Structured logging
- Environment-based configuration management
- Display generator service with error display support
- API service template with caching
- Extensive utility functions for formatting and validation

## Prerequisites

- Python 3.12+
- TRMNL device and API key
- Docker (optional)

## Installation

1. Clone the repository:
```bash
git clone https://github.com/yourusername/your-plugin.git
cd your-plugin
```

2. Create and activate a virtual environment:
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

4. Create .env file:
```bash
cp .env.template .env
```

5. Update .env with your configuration:
```
TRMNL_API_KEY=your_api_key_here
TRMNL_PLUGIN_UUID=your_plugin_uuid_here
```

## Development

### Running Locally

```bash
python -m src.app
```

The development server will automatically open your default browser to the webhook endpoint. You can access:
- Home page: http://localhost:8080/
- Webhook endpoint: http://localhost:8080/webhook

### Project Structure
```
├── .env.template         # Environment variables template
├── .gitignore           # Git ignore rules
├── README.md            # Project documentation
├── render.yaml          # Render deployment configuration
├── requirements.txt     # Python dependencies
├── src/                 # Source code directory
│   ├── app.py          # Main application entry point
│   ├── config.py       # Configuration management
│   ├── services/       # Core services
│   │   ├── api_service.py    # API interaction service
│   │   └── display.py        # Display generation service
│   └── utils/          # Utility functions
│       ├── __init__.py      # Package exports
│       ├── formatters.py    # Data formatting utilities
│       └── validators.py    # Data validation utilities
└── tests/              # Test files
    └── test_display.py  # Display service tests
```

### Core Components

1. **API Service** (`src/services/api_service.py`)
   - Handles all API interactions
   - Implements caching mechanism
   - Tracks last update timestamp

2. **Display Generator** (`src/services/display.py`)
   - Creates optimized images for e-ink display
   - Handles error displays
   - Supports status bar and content layout

3. **Utility Functions**
   - `formatters.py`: Date/time formatting, API response formatting
   - `validators.py`: Data validation, string sanitization
   - Common utilities exported through `__init__.py`

4. **Configuration** (`src/config.py`)
   - Environment-based configuration
   - Validation for required settings
   - Default values for optional settings

### Creating Your Plugin

1. Modify `src/services/api_service.py` to implement your data fetching logic
2. Update `src/services/display.py` to customize the display layout
3. Add any additional utilities in `src/utils/`
4. Update configuration in `src/config.py` as needed

## Testing

Run the test suite:

```bash
python -m pytest tests/
```

Current test coverage includes:
- Display generator initialization
- Error display generation
- API service functionality
- Display creation with mock data

## Deployment

Deploy using render.yaml configuration:

```bash
render deploy
```

The render.yaml file includes:
- Python 3.12.0 runtime
- Gunicorn web server
- Environment variable configuration
- Build and start commands

## Contributing

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

MIT

================
File: render.yaml
================
services:
  - type: web
    name: trmnl-plugin
    env: python
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn src.app:app
    envVars:
      - key: PYTHON_VERSION
        value: 3.12.0
      - key: PORT
        value: 8080
      - key: TRMNL_API_KEY
        sync: false
      - key: TRMNL_PLUGIN_UUID
        sync: false

================
File: requirements.txt
================
flask==3.0.0
pillow==10.1.0
requests==2.31.0
python-dotenv==1.0.0
gunicorn==21.2.0
pytz==2024.1
pymemcache==4.0.0
python-dateutil==2.8.2
flask-cors==4.0.0

================
File: src/app.py
================
from flask import Flask, Response, jsonify
from flask_cors import CORS
import logging
from datetime import datetime, UTC
import traceback
import os
import webbrowser
from threading import Timer

from .config import Config
from .services.display import DisplayGenerator
from .services.api_service import APIService
from .utils.formatters import format_timestamp

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
CORS(app)

# Initialize services
api_service = APIService()
display_generator = DisplayGenerator(Config.DISPLAY_WIDTH, Config.DISPLAY_HEIGHT)

def open_browser():
    webbrowser.open('http://localhost:8080/webhook')

@app.route('/')
def home():
    return jsonify({
        'name': 'TRMNL Plugin',
        'description': 'TRMNL Plugin Boilerplate',
        'version': '1.0.0',
        'status': 'running',
        'last_update': api_service.last_update.isoformat() if api_service.last_update else None,
        'refresh_interval': Config.REFRESH_INTERVAL
    })

@app.route('/webhook', methods=['GET'])
def trmnl_webhook():
    try:
        data = api_service.get_data()
        logger.info(f'Data retrieved: {data}')
        
        image_data = display_generator.create_display(data)
        
        return Response(
            image_data,
            mimetype='image/bmp',
            headers={
                'X-TRMNL-Refresh': str(Config.REFRESH_INTERVAL),
                'X-TRMNL-Plugin-UUID': Config.TRMNL_PLUGIN_UUID
            }
        )
        
    except Exception as e:
        logger.error(f'Webhook error: {str(e)}')
        logger.error(traceback.format_exc())
        return Response(
            display_generator.create_error_display(str(e)),
            mimetype='image/bmp'
        )

if __name__ == '__main__':
    print('=' * 80)
    print('TRMNL Plugin Development Server')
    print('=' * 80)
    print(f'Server URL: http://localhost:{Config.PORT}')
    print(f'Webhook URL: http://localhost:{Config.PORT}/webhook')
    print('-' * 80)
    print('Opening webhook URL in browser...')
    print('Press Ctrl+C to quit')
    print('=' * 80)
    
    # Open browser after a short delay
    Timer(1.5, open_browser).start()
    
    app.run(
        host=Config.HOST,
        port=Config.PORT,
        debug=Config.DEBUG
    )

================
File: src/config.py
================
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class Config:
    '''Application configuration.'''
    
    # Server Configuration
    HOST = os.getenv('HOST', '0.0.0.0')
    PORT = int(os.getenv('PORT', 8080))
    DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'
    
    # Plugin Configuration
    REFRESH_INTERVAL = int(os.getenv('REFRESH_INTERVAL', '900'))
    
    # TRMNL Configuration
    TRMNL_API_KEY = os.getenv('TRMNL_API_KEY')
    TRMNL_PLUGIN_UUID = os.getenv('TRMNL_PLUGIN_UUID')
    
    # Display Configuration
    DISPLAY_WIDTH = int(os.getenv('DISPLAY_WIDTH', '800'))
    DISPLAY_HEIGHT = int(os.getenv('DISPLAY_HEIGHT', '480'))
    
    # Cache Configuration
    CACHE_TIMEOUT = int(os.getenv('CACHE_TIMEOUT', '600'))
    
    @classmethod
    def validate(cls):
        '''Validate required configuration.'''
        required_keys = [
            'TRMNL_API_KEY',
            'TRMNL_PLUGIN_UUID'
        ]
        
        missing_keys = [key for key in required_keys if not getattr(cls, key)]
        
        if missing_keys:
            raise ValueError(
                f"Missing required configuration: {', '.join(missing_keys)}"
            )

================
File: src/services/api_service.py
================
from datetime import datetime, UTC
import logging
import requests
from typing import Optional, Dict, Any
from ..config import Config
from urllib.parse import urlparse, urlunparse
import random

logger = logging.getLogger(__name__)

class APIService:
    '''Service for handling FBI Most Wanted API interactions.'''
    
    BASE_URL = 'https://api.fbi.gov/wanted/v1/list'
    
    def __init__(self):
        self.last_update = None
        self._cached_data = None
        self._cache_timestamp = None
    
    def get_data(self) -> Optional[Dict[str, Any]]:
        '''Get data from FBI Most Wanted API.'''
        try:
            # Check cache first
            if self._is_cache_valid():
                return self._cached_data
            
            # Fetch new data
            data = self._fetch_data()
            
            # Update cache
            self._update_cache(data)
            self.last_update = datetime.now(UTC)
            
            return data
            
        except Exception as e:
            logger.error(f"Error fetching FBI data: {str(e)}")
            return None
    
    def _fetch_data(self) -> Dict[str, Any]:
        '''Fetch data from FBI Most Wanted API with maximum available results.'''
        # First make a request to get the total count
        initial_response = requests.get(self.BASE_URL, params={'page': 1, 'per_page': 1})
        
        if initial_response.status_code != 200:
            raise Exception(f"FBI API returned status code {initial_response.status_code}")
        
        initial_data = initial_response.json()
        total_wanted = initial_data['total']
        
        # Now fetch all results in one request
        response = requests.get(self.BASE_URL, params={
            'page': 1,
            'per_page': total_wanted  # Request maximum available
        })
        
        if response.status_code != 200:
            raise Exception(f"FBI API returned status code {response.status_code}")
        
        api_data = response.json()
        
        # Process the data for display
        processed_data = {
            'timestamp': datetime.now(UTC).isoformat(),
            'total_wanted': total_wanted,
            'wanted_list': []
        }
        
        # Process all available items
        wanted_persons = []
        for item in api_data['items']:
            # Get and process the image URL
            image_url = None
            images = item.get('images', [])
            if images:
                try:
                    raw_url = images[0].get('original', '')
                    if raw_url:
                        parsed = urlparse(raw_url)
                        cleaned_url = urlunparse((
                            'https',
                            'www.fbi.gov',
                            parsed.path.replace('//', '/'),
                            '', '', ''
                        ))
                        image_url = cleaned_url
                except Exception as e:
                    logger.error(f"Error processing image URL: {str(e)}")
                    image_url = None
            
            wanted_person = {
                'title': item.get('title', 'Unknown'),
                'description': item.get('description', ''),
                'reward_text': item.get('reward_text', 'No reward information'),
                'images': image_url,
                'details': item.get('details', ''),
                'status': item.get('status', 'WANTED')
            }
            wanted_persons.append(wanted_person)
        
        # Log the total number of persons processed
        logger.info(f"Processed {len(wanted_persons)} wanted persons out of {total_wanted} total")
        
        # Randomly select one person from all available
        if wanted_persons:
            processed_data['wanted_list'] = [random.choice(wanted_persons)]
        
        return processed_data
    
    def _update_cache(self, data: Dict[str, Any]) -> None:
        '''Update the cache with new data.'''
        self._cached_data = data
        self._cache_timestamp = datetime.now(UTC)
    
    def _is_cache_valid(self) -> bool:
        '''Check if cached data is still valid.'''
        if not self._cache_timestamp:
            return False
            
        cache_age = (datetime.now(UTC) - self._cache_timestamp).total_seconds()
        return cache_age < Config.CACHE_TIMEOUT

================
File: src/services/display.py
================
from PIL import Image, ImageDraw, ImageFont, ImageOps
import io
import logging
import requests
import certifi
import traceback
import base64
from datetime import datetime
from typing import Dict, Any, Optional
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager

logger = logging.getLogger(__name__)

class DisplayGenerator:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        try:
            self.title_font = ImageFont.truetype(font='arial.ttf', size=24)
            self.heading_font = ImageFont.truetype(font='arial.ttf', size=20)
            self.body_font = ImageFont.truetype(font='arial.ttf', size=16)
            self.small_font = ImageFont.truetype(font='arial.ttf', size=12)
        except Exception as e:
            logger.warning(f'Failed to load TrueType font: {e}')
            self.title_font = ImageFont.load_default()
            self.heading_font = self.title_font
            self.body_font = self.title_font
            self.small_font = self.title_font

    def create_display(self, data: Dict[str, Any]) -> Optional[bytes]:
        '''Create FBI Most Wanted display for TRMNL e-ink display.'''
        try:
            if not data or 'wanted_list' not in data:
                return self.create_error_display('No FBI data available')
            
            image = Image.new('1', (self.width, self.height), 1)  # White background
            draw = ImageDraw.Draw(image)
            
            # Draw header
            self._draw_header(draw, data)
            
            # Draw most wanted person
            if data['wanted_list']:
                self._draw_wanted_person(draw, data['wanted_list'][0], image)
            
            # Draw status bar
            self._draw_status_bar(draw, data)
            
            buffer = io.BytesIO()
            image.save(buffer, format='BMP')
            return buffer.getvalue()
            
        except Exception as e:
            logger.error(f'Error generating FBI display: {str(e)}')
            logger.error(traceback.format_exc())
            return self.create_error_display(str(e))

    def _draw_header(self, draw: ImageDraw, data: Dict[str, Any]) -> None:
        '''Draw FBI Most Wanted header.'''
        # Draw title
        draw.text(
            (20, 20),
            'FBI MOST WANTED',
            font=self.title_font,
            fill=0
        )
        
        # Draw total count
        draw.text(
            (20, 50),
            f"Total Wanted: {data.get('total_wanted', 0)}",
            font=self.body_font,
            fill=0
        )

    def _draw_wanted_person(self, draw: ImageDraw, person: Dict[str, Any], image: Image) -> None:
        '''Draw wanted person information with photo.'''
        # Set up dimensions for image placement
        image_width = 250  # Width for person's photo
        image_height = 300  # Max height for photo
        image_x = self.width - image_width - 20  # Position from right edge
        text_width = image_x - 40  # Available width for text
        
        # Draw name/title
        title_lines = self._wrap_text(person['title'], self.heading_font, text_width)
        current_y = 90
        for line in title_lines:
            draw.text(
                (20, current_y),
                line,
                font=self.heading_font,
                fill=0
            )
            current_y += 25

        # Try to fetch and display image
        if person['images']:
            logger.info(f"Attempting to fetch image from URL: {person['images']}")
            wanted_image = self._fetch_image(person['images'])
            
            if wanted_image:
                # Process the image
                wanted_image = wanted_image.convert('L')  # Convert to grayscale
                aspect_ratio = wanted_image.height / wanted_image.width
                target_height = min(image_height, int(image_width * aspect_ratio))
                wanted_image = wanted_image.resize((image_width, target_height))
                
                # Convert to 1-bit black and white with dithering
                wanted_image = wanted_image.convert('1', dither=Image.FLOYDSTEINBERG)
                
                # Paste image onto display
                image.paste(wanted_image, (image_x, 90))
                logger.info("Successfully processed and pasted image")
            else:
                # Create placeholder if image fetch failed
                self._draw_placeholder_image(image, image_x, image_width)

        # Draw status
        if person['status'] and person['status'].lower() != 'na':
            current_y += 10
            draw.text(
                (20, current_y),
                f"Status: {person['status']}",
                font=self.body_font,
                fill=0
            )
            current_y += 25

        # Draw reward text if available
        if person['reward_text']:
            current_y += 10
            reward_lines = self._wrap_text(person['reward_text'], self.body_font, text_width)
            for line in reward_lines[:2]:  # Limit to 2 lines
                draw.text((20, current_y), line, font=self.body_font, fill=0)
                current_y += 25

        # Draw description
        if person['description']:
            current_y += 10
            desc_lines = self._wrap_text(person['description'], self.small_font, text_width)
            for line in desc_lines[:8]:  # Limit to 8 lines
                draw.text((20, current_y), line, font=self.small_font, fill=0)
                current_y += 20

        # Draw details if available and there's space
        if person['details'] and current_y < (self.height - 100):
            current_y += 10
            # Strip HTML tags from details
            import re
            details_text = re.sub('<[^<]+?>', '', person['details'])
            details_lines = self._wrap_text(details_text, self.small_font, text_width)
            remaining_space = (self.height - 100) - current_y
            max_lines = remaining_space // 20
            for line in details_lines[:max_lines]:
                draw.text(
                    (20, current_y),
                    line,
                    font=self.small_font,
                    fill=0
                )
                current_y += 20

    def _draw_status_bar(self, draw: ImageDraw, data: Dict[str, Any]) -> None:
        '''Draw status bar at bottom of display.'''
        status_height = 30
        bar_y = self.height - status_height - 10
        
        # Draw black background for status bar
        draw.rectangle(
            [0, bar_y, self.width, bar_y + status_height],
            fill=0
        )
        
        # Format timestamp
        timestamp = data.get('timestamp', 'Unknown')
        if isinstance(timestamp, str):
            try:
                dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                timestamp = dt.strftime('%Y-%m-%d %H:%M:%S UTC')
            except ValueError:
                pass
        
        # Draw timestamp in white text
        status_text = f'Last Update: {timestamp}'
        draw.text(
            (10, bar_y + 5),
            status_text,
            font=self.small_font,
            fill=1  # White text on black background
        )

    def _draw_placeholder_image(self, image: Image, x: int, width: int) -> None:
        '''Draw a placeholder when image cannot be loaded.'''
        placeholder = Image.new('L', (width, 200), 255)
        draw = ImageDraw.Draw(placeholder)
        draw.text(
            (width//2 - 50, 80),
            "Image\nNot Available",
            font=self.body_font,
            fill=0,
            align='center'
        )
        image.paste(placeholder, (x, 90))

    def _fetch_image(self, url: str) -> Optional[Image.Image]:
        '''Fetch image using Selenium to bypass Cloudflare.'''
        try:
            # First try direct request with proper headers
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36',
                'Accept': 'image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9',
                'Cache-Control': 'no-cache',
                'Pragma': 'no-cache',
                'Referer': 'https://www.fbi.gov/',
                'sec-ch-ua': '"Chromium";v="92", " Not A;Brand";v="99", "Google Chrome";v="92"',
                'sec-ch-ua-mobile': '?0',
                'sec-fetch-dest': 'image',
                'sec-fetch-mode': 'no-cors',
                'sec-fetch-site': 'same-origin',
            }

            session = requests.Session()
            # First visit main site to get cookies
            session.get('https://www.fbi.gov/', headers=headers, timeout=10)
            
            # Now try to get the image
            response = session.get(url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                return Image.open(io.BytesIO(response.content))
            
            # If direct request failed, try using selenium
            from selenium import webdriver
            from selenium.webdriver.chrome.service import Service
            from selenium.webdriver.chrome.options import Options
            from selenium.webdriver.common.by import By
            from selenium.webdriver.support.ui import WebDriverWait
            from selenium.webdriver.support import expected_conditions as EC
            import base64
            
            chrome_options = Options()
            chrome_options.add_argument('--headless')
            chrome_options.add_argument('--no-sandbox')
            chrome_options.add_argument('--disable-dev-shm-usage')
            chrome_options.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36')
            
            from webdriver_manager.chrome import ChromeDriverManager
            service = Service(ChromeDriverManager().install())
            
            with webdriver.Chrome(service=service, options=chrome_options) as driver:
                logger.info(f"Fetching image with Selenium from URL: {url}")
                
                # Navigate to the image URL
                driver.get(url)
                
                # Wait for the image to load
                img_element = WebDriverWait(driver, 10).until(
                    EC.presence_of_element_located((By.TAG_NAME, "img"))
                )
                
                # Get the image as base64
                img_base64 = driver.execute_async_script("""
                    var canvas = document.createElement('canvas');
                    var context = canvas.getContext('2d');
                    var img = document.querySelector('img');
                    var done = arguments[0];
                    
                    function getBase64() {
                        canvas.width = img.width;
                        canvas.height = img.height;
                        context.drawImage(img, 0, 0);
                        done(canvas.toDataURL('image/png').split(',')[1]);
                    }
                    
                    if (img.complete) {
                        getBase64();
                    } else {
                        img.addEventListener('load', getBase64);
                    }
                """)
                
                # Convert base64 to PIL Image
                img_data = base64.b64decode(img_base64)
                return Image.open(io.BytesIO(img_data))
                
        except Exception as e:
            logger.error(f"Error fetching image: {str(e)}")
            logger.error(traceback.format_exc())
            return None

    def create_error_display(self, error_message: str) -> bytes:
        '''Create error display.'''
        image = Image.new('1', (self.width, self.height), 1)
        draw = ImageDraw.Draw(image)
        
        # Draw error header
        draw.text(
            (20, 20),
            'FBI Most Wanted - Error',
            font=self.title_font,
            fill=0
        )
        
        # Draw error message
        error_lines = self._wrap_text(error_message, self.body_font, self.width - 40)
        current_y = 60
        for line in error_lines:
            draw.text(
                (20, current_y),
                line,
                font=self.body_font,
                fill=0
            )
            current_y += 25
        
        buffer = io.BytesIO()
        image.save(buffer, format='BMP')
        return buffer.getvalue()

    def _wrap_text(self, text: str, font: ImageFont, max_width: int) -> list[str]:
        '''Wrap text to fit within specified width.'''
        if not text:
            return []
            
        words = text.split()
        lines = []
        current_line = []
        
        for word in words:
            current_line.append(word)
            line_width = font.getlength(' '.join(current_line))
            if line_width > max_width:
                if len(current_line) == 1:
                    lines.append(current_line[0])
                    current_line = []
                else:
                    current_line.pop()
                    lines.append(' '.join(current_line))
                    current_line = [word]
        
        if current_line:
            lines.append(' '.join(current_line))
        
        return lines

================
File: src/utils/__init__.py
================
from .formatters import (
    format_timestamp,
    format_error_response,
    format_data_response
)

from .validators import (
    validate_timestamp,
    validate_data,
    sanitize_string
)

__all__ = [
    # Formatters
    'format_timestamp',
    'format_error_response',
    'format_data_response',
    
    # Validators
    'validate_timestamp',
    'validate_data',
    'sanitize_string'
]

================
File: src/utils/formatters.py
================
from datetime import datetime, UTC
from typing import Optional, Dict, Any
from flask import jsonify

def format_timestamp(timestamp: str) -> str:
    '''Format timestamp for display.
    
    Args:
        timestamp: ISO format timestamp or UTC timestamp string
        
    Returns:
        Formatted timestamp string in 'YYYY-MM-DD HH:MM UTC' format
    '''
    try:
        # Handle ISO format
        if 'T' in timestamp:
            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        # Handle 'YYYY-MM-DD HH:MM:SS UTC' format
        else:
            dt = datetime.strptime(timestamp.replace(' UTC', ''), '%Y-%m-%d %H:%M:%S')
            dt = dt.replace(tzinfo=UTC)
            
        return dt.strftime('%Y-%m-%d %H:%M UTC')
    except (ValueError, AttributeError):
        return timestamp

def format_error_response(error_message: str, status_code: int = 500) -> Dict[str, Any]:
    '''Format error response for API endpoints.
    
    Args:
        error_message: Error message to return
        status_code: HTTP status code (default 500)
        
    Returns:
        Error response dictionary
    '''
    return jsonify({
        'error': error_message,
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'error'
    }), status_code

def format_data_response(data: Dict[str, Any]) -> Dict[str, Any]:
    '''Format successful data response.
    
    Args:
        data: Data to return
        
    Returns:
        Formatted response dictionary
    '''
    return {
        'data': data,
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'success'
    }

================
File: src/utils/validators.py
================
from datetime import datetime
from typing import Optional, Dict, Any, Tuple
import re

def validate_timestamp(timestamp: str) -> bool:
    '''Validate timestamp format.
    
    Args:
        timestamp: Timestamp string
        
    Returns:
        True if valid, False otherwise
    '''
    # Try ISO format
    try:
        datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        return True
    except ValueError:
        pass
    
    # Try 'YYYY-MM-DD HH:MM:SS UTC' format
    try:
        datetime.strptime(timestamp.replace(' UTC', ''), '%Y-%m-%d %H:%M:%S')
        return True
    except ValueError:
        return False

def validate_data(data: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
    '''Validate data dictionary structure.
    
    Args:
        data: Dictionary containing data to validate
        
    Returns:
        Tuple of (is_valid, error_message)
    '''
    # Add your data validation logic here
    # Example:
    required_fields = ['timestamp']
    
    # Check required fields
    for field in required_fields:
        if field not in data:
            return False, f'Missing required field: {field}'
            
    # Validate timestamp if present
    if 'timestamp' in data and not validate_timestamp(data['timestamp']):
        return False, 'Invalid timestamp format'
    
    return True, None

def sanitize_string(input_str: str, max_length: int = 100) -> str:
    '''Sanitize string input for display.
    
    Args:
        input_str: String to sanitize
        max_length: Maximum allowed length
        
    Returns:
        Sanitized string
    '''
    if not isinstance(input_str, str):
        return ''
    
    # Remove any non-printable characters
    clean_str = ''.join(char for char in input_str if char.isprintable())
    
    # Remove any potential HTML/script tags
    clean_str = re.sub(r'<[^>]*>', '', clean_str)
    
    # Truncate to max length
    return clean_str[:max_length]

================
File: tests/test_display.py
================
from datetime import datetime, UTC
import pytest
from src.services.display import DisplayGenerator
from src.services.api_service import APIService

def test_display_generator_initialization():
    '''Test DisplayGenerator initialization'''
    display = DisplayGenerator(800, 480)
    assert display.width == 800
    assert display.height == 480
    assert display.font is not None

def test_error_display():
    '''Test error display generation'''
    display = DisplayGenerator(800, 480)
    error_msg = 'Test error message'
    image_data = display.create_error_display(error_msg)
    assert image_data is not None
    assert len(image_data) > 0

def test_api_service():
    '''Test APIService basic functionality'''
    service = APIService()
    data = service.get_data()
    assert isinstance(data, dict)
    assert 'timestamp' in data
    assert 'status' in data

def test_display_creation():
    '''Test display creation with mock data'''
    display = DisplayGenerator(800, 480)
    test_data = {
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'ok',
        'test_value': 123
    }
    image_data = display.create_display(test_data)
    assert image_data is not None
    assert len(image_data) > 0
