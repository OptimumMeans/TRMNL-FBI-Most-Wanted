This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-31T04:21:11.765Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.env.template
.gitignore
LICENSE
README.md
render.yaml
requirements.txt
src/app.py
src/assets/DejaVu Fonts License.txt
src/config.py
src/services/api_service.py
src/services/display.py
src/utils/__init__.py
src/utils/formatters.py
src/utils/validators.py
tests/test_display.py

================================================================
Repository Files
================================================================

================
File: .env.template
================
# Server Configuration
PORT=8080
HOST=0.0.0.0
DEBUG=False

# Plugin Configuration
REFRESH_INTERVAL=900  # 15 minutes in seconds

# TRMNL Configuration
TRMNL_API_KEY=your_trmnl_api_key_here
TRMNL_PLUGIN_UUID=your_plugin_uuid_here

# Display Configuration
DISPLAY_WIDTH=800
DISPLAY_HEIGHT=480

# Cache Configuration
CACHE_TIMEOUT=600  # 10 minutes in seconds

================
File: .gitignore
================
# Project-specific files
.env
api_test.py

# Python
__pycache__/
*.py[cod]
*.class
.Python
env/
venv/
build/
dist/
*.egg-info/

# IDE
.idea/
.vscode/
*.swp

# OS
.DS_Store
Thumbs.db

# Logs
*.log
logs/

# Testing
.coverage
htmlcov/
.pytest_cache/

================
File: LICENSE
================
MIT License

Copyright (c) 2024 OptimumMeans

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: README.md
================
# FBI Most Wanted TRMNL Plugin

A TRMNL e-ink display plugin that shows information about FBI Most Wanted fugitives, randomly selecting and displaying one person from the current Most Wanted list.

## Features

- Displays FBI Most Wanted information on TRMNL e-ink display
- Randomly selects one person from the current Most Wanted list
- Shows detailed information including:
  - Photo (when available)
  - Name and status
  - Reward information
  - Description and details
- Advanced image processing for e-ink optimization
- Built-in caching system to minimize API calls
- Comprehensive error handling and display
- Cloudflare-aware image fetching system

## Prerequisites

- Python 3.12+
- TRMNL device and API key
- Chrome/Chromium (for Selenium-based image fetching)
- Docker (optional)

## Installation

1. Clone the repository:
```bash
git clone https://github.com/yourusername/fbi-most-wanted-plugin.git
cd fbi-most-wanted-plugin
```

2. Create and activate a virtual environment:
```bash
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
```

3. Install dependencies:
```bash
pip install -r requirements.txt
```

4. Create .env file:
```bash
cp .env.template .env
```

5. Update .env with your configuration:
```
TRMNL_API_KEY=your_api_key_here
TRMNL_PLUGIN_UUID=your_plugin_uuid_here
CACHE_TIMEOUT=600  # Cache timeout in seconds
```

## Development

### Running Locally

```bash
python -m src.app
```

The development server will automatically open your default browser to:
- Home page: http://localhost:8080/
- Webhook endpoint: http://localhost:8080/webhook

### Project Structure
```
├── .env.template         # Environment variables template
├── .gitignore           # Git ignore rules
├── README.md            # Project documentation
├── render.yaml          # Render deployment configuration
├── requirements.txt     # Python dependencies
├── src/                 # Source code directory
│   ├── app.py          # Main application entry point
│   ├── config.py       # Configuration management
│   ├── services/       # Core services
│   │   ├── api_service.py    # FBI API interaction service
│   │   └── display.py        # Display generation service
│   └── utils/          # Utility functions
│       ├── __init__.py      # Package exports
│       ├── formatters.py    # Data formatting utilities
│       └── validators.py    # Data validation utilities
└── tests/              # Test files
    └── test_display.py  # Display service tests
```

### Core Components

1. **API Service** (`src/services/api_service.py`)
   - Handles FBI Most Wanted API interactions
   - Implements caching mechanism
   - Random selection of wanted persons
   - Image URL processing and validation

2. **Display Generator** (`src/services/display.py`)
   - Creates optimized images for e-ink display
   - Handles error displays
   - Advanced image processing features:
     - Cloudflare bypass for image fetching
     - Dithering optimization for e-ink
     - Dynamic text wrapping and layout
     - Placeholder generation for missing images

3. **Configuration** (`src/config.py`)
   - Environment-based configuration
   - Display dimensions
   - Cache timeout settings
   - API credentials

### FBI API Integration

The plugin integrates with the FBI Most Wanted API (https://api.fbi.gov/wanted/v1/list) to fetch:
- Total number of wanted persons
- Individual profiles including:
  - Name and status
  - Description and details
  - Reward information
  - Photo URLs

### Display Features

The plugin creates an optimized display showing:
1. Header with FBI Most Wanted title and total count
2. Main content area with:
   - Person's name/title
   - Status
   - Photo (if available)
   - Reward information
   - Description
   - Additional details
3. Status bar with last update timestamp

## Testing

Run the test suite:

```bash
python -m pytest tests/
```

Current test coverage includes:
- Display generator initialization
- Error display generation
- API service functionality
- Display creation with mock data

## Deployment

Deploy using render.yaml configuration:

```bash
render deploy
```

The render.yaml file includes:
- Python 3.12.0 runtime
- Gunicorn web server
- Environment variable configuration
- Chrome/Chromium dependencies

## Contributing

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

MIT

================
File: render.yaml
================
services:
  - type: web
    name: trmnl-fbi-most-wanted
    env: python
    buildCommand: |
      pip install -r requirements.txt
      # Install wget for cron job
      apt-get update && apt-get install -y wget ca-certificates
    startCommand: gunicorn src.app:app
    envVars:
      - key: PYTHON_VERSION
        value: 3.12.0
      - key: PORT
        value: 8080
      - key: TRMNL_API_KEY
        sync: false
      - key: TRMNL_PLUGIN_UUID
        sync: false
      - key: CACHE_TIMEOUT
        value: 600
      - key: REFRESH_INTERVAL
        value: 900

  - type: cron
    name: trmnl-fbi-refresh
    env: python
    schedule: "*/5 * * * *"  # Run every 5 minutes
    buildCommand: pip install -r requirements.txt
    startCommand: |
      # Robust wget command with retry and proper SSL handling
      wget --retry-connrefused --waitretry=1 --read-timeout=20 --timeout=15 -t 3 \
           --no-check-certificate \
           -qO- https://trmnl-fbi-most-wanted.onrender.com/webhook || \
      curl -k -L --retry 3 --retry-delay 1 --retry-max-time 30 \
           https://trmnl-fbi-most-wanted.onrender.com/webhook
    envVars:
      - key: PYTHON_VERSION
        value: 3.12.0
      - key: PORT
        fromService:
          name: trmnl-fbi-most-wanted
          type: web
          envVarKey: PORT
      - key: SSL_CERT_FILE
        value: /etc/ssl/certs/ca-certificates.crt
      - key: PYTHONWARNINGS
        value: "ignore:Unverified HTTPS request"

================
File: requirements.txt
================
flask==3.0.0
pillow==10.1.0
requests==2.31.0
python-dotenv==1.0.0
gunicorn==21.2.0
pytz==2024.1
pymemcache==4.0.0
python-dateutil==2.8.2
flask-cors==4.0.0
selenium==4.16.0
webdriver-manager==4.0.1
certifi==2023.11.17
qrcode==7.4.2

================
File: src/app.py
================
from flask import Flask, Response, jsonify
from flask_cors import CORS
import logging
from datetime import datetime, UTC
import traceback
import os
import webbrowser
from threading import Timer

from .config import Config
from .services.display import DisplayGenerator
from .services.api_service import APIService
from .utils.formatters import format_timestamp

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
CORS(app)

# Initialize services
api_service = APIService()
display_generator = DisplayGenerator(Config.DISPLAY_WIDTH, Config.DISPLAY_HEIGHT)

def open_browser():
    webbrowser.open('http://localhost:8080/webhook')

@app.route('/')
def home():
    return jsonify({
        'name': 'TRMNL Plugin',
        'description': 'TRMNL Plugin Boilerplate',
        'version': '1.0.0',
        'status': 'running',
        'last_update': api_service.last_update.isoformat() if api_service.last_update else None,
        'refresh_interval': Config.REFRESH_INTERVAL
    })

@app.route('/webhook', methods=['GET'])
def trmnl_webhook():
    try:
        data = api_service.get_data()
        logger.info(f'Data retrieved: {data}')
        
        image_data = display_generator.create_display(data)
        
        return Response(
            image_data,
            mimetype='image/bmp',
            headers={
                'X-TRMNL-Refresh': str(Config.REFRESH_INTERVAL),
                'X-TRMNL-Plugin-UUID': Config.TRMNL_PLUGIN_UUID
            }
        )
        
    except Exception as e:
        logger.error(f'Webhook error: {str(e)}')
        logger.error(traceback.format_exc())
        return Response(
            display_generator.create_error_display(str(e)),
            mimetype='image/bmp'
        )

if __name__ == '__main__':
    print('=' * 80)
    print('TRMNL Plugin Development Server')
    print('=' * 80)
    print(f'Server URL: http://localhost:{Config.PORT}')
    print(f'Webhook URL: http://localhost:{Config.PORT}/webhook')
    print('-' * 80)
    print('Opening webhook URL in browser...')
    print('Press Ctrl+C to quit')
    print('=' * 80)
    
    # Open browser after a short delay
    Timer(1.5, open_browser).start()
    
    app.run(
        host=Config.HOST,
        port=Config.PORT,
        debug=Config.DEBUG
    )

================
File: src/assets/DejaVu Fonts License.txt
================
Fonts are (c) Bitstream (see below). DejaVu changes are in public domain.
Glyphs imported from Arev fonts are (c) Tavmjong Bah (see below)

Bitstream Vera Fonts Copyright
------------------------------

Copyright (c) 2003 by Bitstream, Inc. All Rights Reserved. Bitstream Vera is
a trademark of Bitstream, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of the fonts accompanying this license ("Fonts") and associated
documentation files (the "Font Software"), to reproduce and distribute the
Font Software, including without limitation the rights to use, copy, merge,
publish, distribute, and/or sell copies of the Font Software, and to permit
persons to whom the Font Software is furnished to do so, subject to the
following conditions:

The above copyright and trademark notices and this permission notice shall
be included in all copies of one or more of the Font Software typefaces.

The Font Software may be modified, altered, or added to, and in particular
the designs of glyphs or characters in the Fonts may be modified and
additional glyphs or characters may be added to the Fonts, only if the fonts
are renamed to names not containing either the words "Bitstream" or the word
"Vera".

This License becomes null and void to the extent applicable to Fonts or Font
Software that has been modified and is distributed under the "Bitstream
Vera" names.

The Font Software may be sold as part of a larger software package but no
copy of one or more of the Font Software typefaces may be sold by itself.

THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT,
TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL BITSTREAM OR THE GNOME
FOUNDATION BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING
ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE
FONT SOFTWARE.

Except as contained in this notice, the names of Gnome, the Gnome
Foundation, and Bitstream Inc., shall not be used in advertising or
otherwise to promote the sale, use or other dealings in this Font Software
without prior written authorization from the Gnome Foundation or Bitstream
Inc., respectively. For further information, contact: fonts at gnome dot
org. 

Arev Fonts Copyright
------------------------------

Copyright (c) 2006 by Tavmjong Bah. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of the fonts accompanying this license ("Fonts") and
associated documentation files (the "Font Software"), to reproduce
and distribute the modifications to the Bitstream Vera Font Software,
including without limitation the rights to use, copy, merge, publish,
distribute, and/or sell copies of the Font Software, and to permit
persons to whom the Font Software is furnished to do so, subject to
the following conditions:

The above copyright and trademark notices and this permission notice
shall be included in all copies of one or more of the Font Software
typefaces.

The Font Software may be modified, altered, or added to, and in
particular the designs of glyphs or characters in the Fonts may be
modified and additional glyphs or characters may be added to the
Fonts, only if the fonts are renamed to names not containing either
the words "Tavmjong Bah" or the word "Arev".

This License becomes null and void to the extent applicable to Fonts
or Font Software that has been modified and is distributed under the 
"Tavmjong Bah Arev" names.

The Font Software may be sold as part of a larger software package but
no copy of one or more of the Font Software typefaces may be sold by
itself.

THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL
TAVMJONG BAH BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.

Except as contained in this notice, the name of Tavmjong Bah shall not
be used in advertising or otherwise to promote the sale, use or other
dealings in this Font Software without prior written authorization
from Tavmjong Bah. For further information, contact: tavmjong @ free
. fr.

================
File: src/config.py
================
import os
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

class Config:
    '''Application configuration.'''
    
    # Server Configuration
    HOST = os.getenv('HOST', '0.0.0.0')
    PORT = int(os.getenv('PORT', 8080))
    DEBUG = os.getenv('DEBUG', 'False').lower() == 'true'
    
    # Plugin Configuration
    REFRESH_INTERVAL = int(os.getenv('REFRESH_INTERVAL', '900'))
    
    # TRMNL Configuration
    TRMNL_API_KEY = os.getenv('TRMNL_API_KEY')
    TRMNL_PLUGIN_UUID = os.getenv('TRMNL_PLUGIN_UUID')
    
    # Display Configuration
    DISPLAY_WIDTH = int(os.getenv('DISPLAY_WIDTH', '800'))
    DISPLAY_HEIGHT = int(os.getenv('DISPLAY_HEIGHT', '480'))
    
    # Cache Configuration
    CACHE_TIMEOUT = int(os.getenv('CACHE_TIMEOUT', '600'))
    
    @classmethod
    def validate(cls):
        '''Validate required configuration.'''
        required_keys = [
            'TRMNL_API_KEY',
            'TRMNL_PLUGIN_UUID'
        ]
        
        missing_keys = [key for key in required_keys if not getattr(cls, key)]
        
        if missing_keys:
            raise ValueError(
                f"Missing required configuration: {', '.join(missing_keys)}"
            )

================
File: src/services/api_service.py
================
from datetime import datetime, UTC
import logging
import requests
from typing import Optional, Dict, Any
from ..config import Config
from urllib.parse import urlparse, urlunparse
import random

logger = logging.getLogger(__name__)

class APIService:
    '''Service for handling FBI Most Wanted API interactions.'''
    
    BASE_URL = 'https://api.fbi.gov/wanted/v1/list'
    
    def __init__(self):
        self.last_update = None
        self._cached_data = None
        self._cache_timestamp = None
    
    def get_data(self) -> Optional[Dict[str, Any]]:
        '''Get data from FBI Most Wanted API.'''
        try:
            # Check cache first
            if self._is_cache_valid():
                return self._cached_data
            
            # Fetch new data
            data = self._fetch_data()
            
            # Update cache
            self._update_cache(data)
            self.last_update = datetime.now(UTC)
            
            return data
            
        except Exception as e:
            logger.error(f"Error fetching FBI data: {str(e)}")
            return None
    
    def _fetch_data(self) -> Dict[str, Any]:
        '''Fetch data from FBI Most Wanted API with maximum available results.'''
        # First make a request to get the total count
        initial_response = requests.get(self.BASE_URL, params={'page': 1, 'per_page': 1})
        
        if initial_response.status_code != 200:
            raise Exception(f"FBI API returned status code {initial_response.status_code}")
        
        initial_data = initial_response.json()
        total_wanted = initial_data['total']
        
        # Now fetch all results in one request
        response = requests.get(self.BASE_URL, params={
            'page': 1,
            'per_page': total_wanted  # Request maximum available
        })
        
        if response.status_code != 200:
            raise Exception(f"FBI API returned status code {response.status_code}")
        
        api_data = response.json()
        
        # Process the data for display
        processed_data = {
            'timestamp': datetime.now(UTC).isoformat(),
            'total_wanted': total_wanted,
            'wanted_list': []
        }
        
        # Process all available items
        wanted_persons = []
        for item in api_data['items']:
            # Get and process the image URL
            image_url = None
            images = item.get('images', [])
            if images:
                try:
                    raw_url = images[0].get('original', '')
                    if raw_url:
                        parsed = urlparse(raw_url)
                        cleaned_url = urlunparse((
                            'https',
                            'www.fbi.gov',
                            parsed.path.replace('//', '/'),
                            '', '', ''
                        ))
                        image_url = cleaned_url
                except Exception as e:
                    logger.error(f"Error processing image URL: {str(e)}")
                    image_url = None
            
            wanted_person = {
            'title': item.get('title', 'Unknown'),
            'description': item.get('description', ''),
            'reward_text': item.get('reward_text', 'No reward information'),
            'images': image_url,
            'details': item.get('details', ''),
            'status': item.get('status', 'WANTED'),
            'url': item.get('url', f"https://www.fbi.gov/wanted//@/item/{item.get('uid', '')}")
        }
            wanted_persons.append(wanted_person)
        
        # Log the total number of persons processed
        logger.info(f"Processed {len(wanted_persons)} wanted persons out of {total_wanted} total")
        
        # Randomly select one person from all available
        if wanted_persons:
            processed_data['wanted_list'] = [random.choice(wanted_persons)]
        
        return processed_data
    
    def _update_cache(self, data: Dict[str, Any]) -> None:
        '''Update the cache with new data.'''
        self._cached_data = data
        self._cache_timestamp = datetime.now(UTC)
    
    def _is_cache_valid(self) -> bool:
        '''Check if cached data is still valid.'''
        if not self._cache_timestamp:
            return False
            
        cache_age = (datetime.now(UTC) - self._cache_timestamp).total_seconds()
        return cache_age < Config.CACHE_TIMEOUT

================
File: src/services/display.py
================
from PIL import Image, ImageDraw, ImageFont, ImageOps
import io
import os
import logging
import qrcode
import requests
import certifi
import traceback
import re
import base64
from datetime import datetime
from typing import Dict, Any, Optional
import urllib.parse
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager

logger = logging.getLogger(__name__)

class DisplayGenerator:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        try:
            # Get the path to the DejaVu font in the assets directory
            current_dir = os.path.dirname(os.path.abspath(__file__))
            font_path = os.path.join(current_dir, '..', 'assets', 'DejaVuSans.ttf')
            
            logger.info(f'Loading font from: {font_path}')
            
            # Initialize fonts with DejaVu
            self.title_font = ImageFont.truetype(font=font_path, size=32)
            self.subtitle_font = ImageFont.truetype(font=font_path, size=16)
            self.name_font = ImageFont.truetype(font=font_path, size=24)
            self.heading_font = ImageFont.truetype(font=font_path, size=18)
            self.date_font = ImageFont.truetype(font=font_path, size=16)
            self.body_font = ImageFont.truetype(font=font_path, size=16)
            self.small_font = ImageFont.truetype(font=font_path, size=14)
        except Exception as e:
            logger.warning(f'Failed to load TrueType font: {e}')
            self.title_font = ImageFont.load_default()
            self.subtitle_font = self.title_font
            self.name_font = self.title_font
            self.heading_font = self.title_font
            self.date_font = self.title_font
            self.body_font = self.title_font
            self.small_font = self.title_font

    def create_display(self, data: Dict[str, Any]) -> Optional[bytes]:
        '''Create FBI Most Wanted display for TRMNL e-ink display.'''
        try:
            if not data or 'wanted_list' not in data:
                return self.create_error_display('No FBI data available')
            
            image = Image.new('1', (self.width, self.height), 1)  # White background
            draw = ImageDraw.Draw(image)
            
            # Draw header
            self._draw_header(draw, data)
            
            # Draw most wanted person
            if data['wanted_list']:
                self._draw_wanted_person(draw, data['wanted_list'][0], image)
            
            # Draw status bar
            self._draw_status_bar(draw, data)
            
            buffer = io.BytesIO()
            image.save(buffer, format='BMP')
            return buffer.getvalue()
            
        except Exception as e:
            logger.error(f'Error generating FBI display: {str(e)}')
            logger.error(traceback.format_exc())
            return self.create_error_display(str(e))
        
    def _generate_qr_code(self, url: str, size: int = 100) -> Image.Image:
        '''Generate QR code for FBI Most Wanted URL.'''
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=2,
            border=2,
        )
        qr.add_data(url)
        qr.make(fit=True)
        
        # Create QR code image
        qr_image = qr.make_image(fill_color="black", back_color="white")
        
        # Resize to desired dimensions
        qr_image = qr_image.resize((size, size), Image.Resampling.NEAREST)
        return qr_image

    def _draw_header(self, draw: ImageDraw, data: Dict[str, Any]) -> None:
        '''Draw FBI Most Wanted header.'''
        # Draw main title in large font
        draw.text(
            (20, 15),
            'FBI MOST WANTED',
            font=self.title_font,
            fill=0
        )
        
        # Draw total count in smaller font
        draw.text(
            (20, 50),
            f"Total Wanted: {data.get('total_wanted', 0)}",
            font=self.subtitle_font,
            fill=0
        )

    def _draw_wanted_person(self, draw: ImageDraw, person: Dict[str, Any], image: Image) -> None:
        '''Draw wanted person information with photo.'''
        # Image dimensions
        right_margin = 20
        image_width = 200
        image_height = 240
        image_x = self.width - image_width - right_margin
        image_y = 80
        text_width = image_x - 40

        # Draw name/title in large bold font
        current_y = 80
        title_lines = self._wrap_text(person['title'], self.name_font, text_width)
        for line in title_lines:
            draw.text(
                (20, current_y),
                line,
                font=self.name_font,
                fill=0
            )
            current_y += 30  # More space between name lines

        # Draw location/date
        current_y += 5  # Small gap after name
        if person['description']:
            desc_parts = person['description'].split('\r\n')
            if len(desc_parts) >= 2:
                # Draw date and location on separate lines
                draw.text(
                    (20, current_y),
                    desc_parts[0],  # Date
                    font=self.date_font,
                    fill=0
                )
                current_y += 20
                draw.text(
                    (20, current_y),
                    desc_parts[1],  # Location
                    font=self.date_font,
                    fill=0
                )
                current_y += 25

        # Process and draw image
        if person['images']:
            wanted_image = self._fetch_image(person['images'])
            if wanted_image:
                wanted_image = wanted_image.convert('L')
                aspect_ratio = wanted_image.height / wanted_image.width
                target_width = image_width
                target_height = int(image_width * aspect_ratio)
                
                if target_height > image_height:
                    target_height = image_height
                    target_width = int(image_height / aspect_ratio)
                    image_x = self.width - target_width - right_margin
                
                wanted_image = wanted_image.resize((target_width, target_height), Image.Resampling.LANCZOS)
                wanted_image = wanted_image.convert('1', dither=Image.FLOYDSTEINBERG)
                image.paste(wanted_image, (image_x, image_y))
            else:
                self._draw_placeholder_image(image, image_x, image_width)

        # Draw details text
        if person['details']:
            current_y += 15
            details_text = re.sub('<[^<]+?>', '', person['details'])
            details_lines = self._wrap_text(details_text, self.body_font, text_width)
            for line in details_lines[:8]:
                draw.text(
                    (20, current_y),
                    line,
                    font=self.body_font,
                    fill=0
                )
                current_y += 22
                
        # Calculate QR code position
        # Place it in bottom right, above status bar
        qr_size = 100
        qr_x = self.width - qr_size - 20  # 20px margin from right
        qr_y = self.height - qr_size - 50  # 50px up from bottom to clear status bar

        # Generate and paste QR code if URL is available
        if person.get('url'):
            qr_image = self._generate_qr_code(person['url'], qr_size)
            image.paste(qr_image, (qr_x, qr_y))
            
            # Add "Scan for details" text above QR code
            draw.text(
                (qr_x, qr_y - 20),
                "Scan for details",
                font=self.small_font,
                fill=0
            )

    def _draw_status_bar(self, draw: ImageDraw, data: Dict[str, Any]) -> None:
        '''Draw status bar at bottom of display.'''
        status_height = 30
        bar_y = self.height - status_height - 10
        
        # Draw black background for status bar
        draw.rectangle(
            [0, bar_y, self.width, bar_y + status_height],
            fill=0
        )
        
        # Format timestamp
        timestamp = data.get('timestamp', 'Unknown')
        if isinstance(timestamp, str):
            try:
                dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                timestamp = dt.strftime('%Y-%m-%d %H:%M:%S UTC')
            except ValueError:
                pass
        
        # Draw timestamp in white text
        status_text = f'Last Update: {timestamp}'
        draw.text(
            (10, bar_y + 5),
            status_text,
            font=self.small_font,
            fill=1  # White text on black background
        )

    def _draw_placeholder_image(self, image: Image, x: int, width: int) -> None:
        '''Draw a placeholder when image cannot be loaded.'''
        placeholder = Image.new('L', (width, 200), 255)
        draw = ImageDraw.Draw(placeholder)
        draw.text(
            (width//2 - 50, 80),
            "Image\nNot Available",
            font=self.body_font,
            fill=0,
            align='center'
        )
        image.paste(placeholder, (x, 90))

    def _fetch_image(self, url: str) -> Optional[Image.Image]:
        '''Fetch image using image proxy service to bypass restrictions.'''
        try:
            # Encode the FBI URL for the proxy service
            encoded_url = urllib.parse.quote_plus(url)
            proxy_url = f'https://wsrv.nl/?url={encoded_url}'
            
            logger.info(f"Attempting to fetch image via proxy: {proxy_url}")
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8'
            }
            
            response = requests.get(proxy_url, headers=headers, timeout=15, verify=False)
            
            if response.status_code == 200:
                logger.info("Successfully fetched image via proxy")
                return Image.open(io.BytesIO(response.content))
            else:
                logger.warning(f"Proxy request failed with status code: {response.status_code}")
                
                # Try alternative proxy URL format
                alt_proxy_url = f'https://images.weserv.nl/?url={encoded_url}'
                logger.info(f"Attempting alternate proxy URL: {alt_proxy_url}")
                
                response = requests.get(alt_proxy_url, headers=headers, timeout=15, verify=False)
                
                if response.status_code == 200:
                    logger.info("Successfully fetched image via alternate proxy")
                    return Image.open(io.BytesIO(response.content))
                else:
                    logger.error(f"All proxy attempts failed. Final status code: {response.status_code}")
                    return None
                
        except Exception as e:
            logger.error(f"Error in image fetch process: {str(e)}")
            logger.error(traceback.format_exc())
            return None

    def create_error_display(self, error_message: str) -> bytes:
        '''Create error display.'''
        image = Image.new('1', (self.width, self.height), 1)
        draw = ImageDraw.Draw(image)
        
        # Draw error header
        draw.text(
            (20, 20),
            'FBI Most Wanted - Error',
            font=self.title_font,
            fill=0
        )
        
        # Draw error message
        error_lines = self._wrap_text(error_message, self.body_font, self.width - 40)
        current_y = 60
        for line in error_lines:
            draw.text(
                (20, current_y),
                line,
                font=self.body_font,
                fill=0
            )
            current_y += 25
        
        buffer = io.BytesIO()
        image.save(buffer, format='BMP')
        return buffer.getvalue()

    def _wrap_text(self, text: str, font: ImageFont, max_width: int) -> list[str]:
        '''Wrap text to fit within specified width.'''
        if not text:
            return []
            
        words = text.split()
        lines = []
        current_line = []
        
        for word in words:
            current_line.append(word)
            line_width = font.getlength(' '.join(current_line))
            if line_width > max_width:
                if len(current_line) == 1:
                    lines.append(current_line[0])
                    current_line = []
                else:
                    current_line.pop()
                    lines.append(' '.join(current_line))
                    current_line = [word]
        
        if current_line:
            lines.append(' '.join(current_line))
        
        return lines

================
File: src/utils/__init__.py
================
from .formatters import (
    format_timestamp,
    format_error_response,
    format_data_response
)

from .validators import (
    validate_timestamp,
    validate_data,
    sanitize_string
)

__all__ = [
    # Formatters
    'format_timestamp',
    'format_error_response',
    'format_data_response',
    
    # Validators
    'validate_timestamp',
    'validate_data',
    'sanitize_string'
]

================
File: src/utils/formatters.py
================
from datetime import datetime, UTC
from typing import Optional, Dict, Any
from flask import jsonify

def format_timestamp(timestamp: str) -> str:
    '''Format timestamp for display.
    
    Args:
        timestamp: ISO format timestamp or UTC timestamp string
        
    Returns:
        Formatted timestamp string in 'YYYY-MM-DD HH:MM UTC' format
    '''
    try:
        # Handle ISO format
        if 'T' in timestamp:
            dt = datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        # Handle 'YYYY-MM-DD HH:MM:SS UTC' format
        else:
            dt = datetime.strptime(timestamp.replace(' UTC', ''), '%Y-%m-%d %H:%M:%S')
            dt = dt.replace(tzinfo=UTC)
            
        return dt.strftime('%Y-%m-%d %H:%M UTC')
    except (ValueError, AttributeError):
        return timestamp

def format_error_response(error_message: str, status_code: int = 500) -> Dict[str, Any]:
    '''Format error response for API endpoints.
    
    Args:
        error_message: Error message to return
        status_code: HTTP status code (default 500)
        
    Returns:
        Error response dictionary
    '''
    return jsonify({
        'error': error_message,
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'error'
    }), status_code

def format_data_response(data: Dict[str, Any]) -> Dict[str, Any]:
    '''Format successful data response.
    
    Args:
        data: Data to return
        
    Returns:
        Formatted response dictionary
    '''
    return {
        'data': data,
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'success'
    }

================
File: src/utils/validators.py
================
from datetime import datetime
from typing import Optional, Dict, Any, Tuple
import re

def validate_timestamp(timestamp: str) -> bool:
    '''Validate timestamp format.
    
    Args:
        timestamp: Timestamp string
        
    Returns:
        True if valid, False otherwise
    '''
    # Try ISO format
    try:
        datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
        return True
    except ValueError:
        pass
    
    # Try 'YYYY-MM-DD HH:MM:SS UTC' format
    try:
        datetime.strptime(timestamp.replace(' UTC', ''), '%Y-%m-%d %H:%M:%S')
        return True
    except ValueError:
        return False

def validate_data(data: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
    '''Validate data dictionary structure.
    
    Args:
        data: Dictionary containing data to validate
        
    Returns:
        Tuple of (is_valid, error_message)
    '''
    # Add your data validation logic here
    # Example:
    required_fields = ['timestamp']
    
    # Check required fields
    for field in required_fields:
        if field not in data:
            return False, f'Missing required field: {field}'
            
    # Validate timestamp if present
    if 'timestamp' in data and not validate_timestamp(data['timestamp']):
        return False, 'Invalid timestamp format'
    
    return True, None

def sanitize_string(input_str: str, max_length: int = 100) -> str:
    '''Sanitize string input for display.
    
    Args:
        input_str: String to sanitize
        max_length: Maximum allowed length
        
    Returns:
        Sanitized string
    '''
    if not isinstance(input_str, str):
        return ''
    
    # Remove any non-printable characters
    clean_str = ''.join(char for char in input_str if char.isprintable())
    
    # Remove any potential HTML/script tags
    clean_str = re.sub(r'<[^>]*>', '', clean_str)
    
    # Truncate to max length
    return clean_str[:max_length]

================
File: tests/test_display.py
================
from datetime import datetime, UTC
import pytest
from src.services.display import DisplayGenerator
from src.services.api_service import APIService

def test_display_generator_initialization():
    '''Test DisplayGenerator initialization'''
    display = DisplayGenerator(800, 480)
    assert display.width == 800
    assert display.height == 480
    assert display.font is not None

def test_error_display():
    '''Test error display generation'''
    display = DisplayGenerator(800, 480)
    error_msg = 'Test error message'
    image_data = display.create_error_display(error_msg)
    assert image_data is not None
    assert len(image_data) > 0

def test_api_service():
    '''Test APIService basic functionality'''
    service = APIService()
    data = service.get_data()
    assert isinstance(data, dict)
    assert 'timestamp' in data
    assert 'status' in data

def test_display_creation():
    '''Test display creation with mock data'''
    display = DisplayGenerator(800, 480)
    test_data = {
        'timestamp': datetime.now(UTC).isoformat(),
        'status': 'ok',
        'test_value': 123
    }
    image_data = display.create_display(test_data)
    assert image_data is not None
    assert len(image_data) > 0
